#include<bits/stdc++.h>
using namespace std;
int n;
int a[20],b[20]={0};
/*1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1  这个递归真的很有意思，不断回到前一层用i来遍历，但是有点难以理解
第一次循环时，i=1。由于b[1]为0，表示1还没有被使用过，因此将1放在当前位置a[1]，并将b[1]标记为已使用。然后递归调用dfs(2)。
当k=2时，程序再次进入循环for(int i=1;i<=n;i++)。
第一次循环时，i=1。由于b[1]已经被标记为1，表示1已经被使用过，因此跳过这个循环。
第二次循环时，i=2。由于b[2]为0，表示2还没有被使用过，因此将2放在当前位置a[2]，并将b[2]标记为已使用。然后递归调用dfs(3)。
当k=3时，程序再次进入循环for(int i=1;i<=n;i++)。
第一次循环时，i=1。由于b[1]已经被标记为1，表示1已经被使用过，因此跳过这个循环。
第二次循环时，i=2。由于b[2]已经被标记为1，表示2已经被使用过，因此跳过这个循环。
第三次循环时，i=3。由于b[3]为0，表示3还没有被使用过，因此将3放在当前位置a[3]，并将b[3]标记为已使用。此时，已经确定了一种排列{1, 2, 3}，输出该排列。
递归结束后，将b[3]重新标记为0，以便后续的排列生成。
接着，程序回到k=2的循环，将b[2]重新标记为0。*/
void dfs(int k)
{
    if(k==n+1)
    {
        for(int i=1;i<=n;i++)
        {
            printf("%d ",a[i]);
        }
        printf("\n");
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(b[i]==0)
        {
            a[k]=i;
            b[i]=1;
            dfs(k+1);
            b[i]=0;
        }
    }

}
int main()
{
    cin>>n;
    dfs(1);
    return 0;
}